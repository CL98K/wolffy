(in-package #:pickle)

(eval-when (:compile-toplevel :load-toplevel :execute)
  (setf *read-default-float-format* 'double-float)
  (setf *cond-exp* '(cond (t (error 'unpickling-error :message (format nil "Not implemented(~A)" op-code)))))
  (setf *built-exp* nil)
  
  (defmacro transfer (name args body)
    `(defun ,name ,args ,@body))

  (set-macro-character #\@ (lambda (stream char)
                             (declare (ignore char))
                             (let* ((decorator (read stream nil))
                                    (form (read stream nil)))
                               (push (cdr form) *built-exp*)
                               `(transfer ,(cadr form) ,(caddr form) ,(cdddr form)))))

  (defparameter *op-func* (make-hash-table))

  (defun type-to-code (obj)
    (typecase obj
      (nil        1000)
      (boolean    1001)
      (integer    1010)
      (float      1020)
      (string     1030)
      (list       1040)
      (array      1050)
      (hash-table 1060)
      (symbol     1070)
      (t          2000))))

(declaim (ftype (function (fixnum hash-table wo-io:binary-stream t) t) perform-op) (inline perform-op))
(defun perform-op (op-code env stream obj)
  (declare (optimize (speed 3) (safety 0) (debug 0) (compilation-speed 3))
           (type fixnum op-code) (type hash-table env) (type wo-io:binary-stream stream) (type t obj))

  (if (gethash op-code *op-func*)
      (funcall (the function (gethash op-code *op-func*)) env stream obj)
      (error 'unpickling-error :message (format nil "Not implemented(~A)" op-code))))

(defmacro define-fast-op (name args modify-item &body body)  
  (let* ((modify-item (eval modify-item))
         (built-exp (sublis modify-item *built-exp* :test #'equal))
         (cond-exp (sublis modify-item *cond-exp* :test #'equal))
         (nbody (sublis (acons '*built-exp* built-exp '()) body :test #'equal))
         (nbody (sublis (acons '*cond-exp* cond-exp '()) nbody :test #'equal)))    
    `(defun ,name ,args ,@nbody)))

(defmacro defop (name (&optional env stream obj) &body body)
  (rplacd *cond-exp* (append `(((eq op-code ,name) (block nil ,@body))) (cdr *cond-exp*)))
 
  (let ((e (or env (gensym)))
        (s (or stream (gensym)))
        (o (or obj (gensym))))
    `(setf (gethash ,name *op-func*) #'(lambda (,e ,s ,o) ,(cond
                                                             ((and (not stream) (not obj)) `(declare (optimize (speed 3) (safety 0) (debug 0) (compilation-speed 3)) (type hash-table ,e) (ignore ,s ,o)))
                                                             ((not stream) `(declare (optimize (speed 3) (safety 0) (debug 0) (compilation-speed 3)) (type hash-table ,e) (ignore ,s)))
                                                             ((not obj) `(declare (optimize (speed 3) (safety 0) (debug 0) (compilation-speed 3)) (type hash-table ,e) (ignore ,o))))
                                         (block nil ,@body)))))

(macrolet ((add-op (name code doc)
             `(defconstant ,name ,(if (typep code 'character)
                                 `,(char-code code)
                                 `,code)
                ,doc)))
  (add-op +mark+             #\(  "push special markobject on stack")
  (add-op +stop+             #\.  "every pickle ends with STOP")
  (add-op +pop+              #\0  "discard topmost stack item")
  (add-op +pop-mark+         #\1  "discard stack top through topmost markobject")
  (add-op +dup+              #\2  "duplicate top stack item")
  (add-op +float+            #\F  "push float object; decimal string argument")
  (add-op +int+              #\I  "push integer or bool; decimal string argument")
  (add-op +binint+           #\J  "push four-byte signed int")
  (add-op +binint1+          #\K  "push 1-byte unsigned int")
  (add-op +long+             #\L  "push long; decimal string argument")
  (add-op +binint2+          #\M  "push 2-byte unsigned int")
  (add-op +none+             #\N  "push None")
  (add-op +persid+           #\P  "push persistent object; id is taken from string arg")
  (add-op +binpersid+        #\Q  "Push persistent object; id is taken from stack")
  (add-op +reduce+           #\R  "apply callable to argtuple, both on stack")
  (add-op +string+           #\S  "push string; NL-terminated string argument")
  (add-op +binstring+        #\T  "push string; counted binary string argument")
  (add-op +short-binstring+  #\U  "Push string; counted binary string argument < 256 bytes")
  (add-op +unicode+          #\V  "push Unicode string; raw-unicode-escaped'd argument")
  (add-op +binunicode+       #\X  "Push unicode string; counted UTF-8 string argument")
  (add-op +append+           #\a  "append stack top to list below it")
  (add-op +build+            #\b  "call __setstate__ or __dict__.update()")
  (add-op +global+           #\c  "push self.find_class(modname, name); 2 string args")
  (add-op +dict+             #\d  "build a dict from stack items")
  (add-op +empty-dict+       #\}  "push empty dict")
  (add-op +appends+          #\e  "extend list on stack by topmost stack slice")
  (add-op +get+              #\g  "push item from memo on stack; index is string arg")
  (add-op +binget+           #\h  "Push item from memo on stack; index is 1-byte arg")
  (add-op +inst+             #\i  "build & push class instance")
  (add-op +long-binget+      #\j  "push item from memo on stack; index is 4-byte arg")
  (add-op +list+             #\l  "build list from topmost stack items")
  (add-op +empty-list+       #\]  "push empty list")
  (add-op +obj+              #\o  "build & push class instance")
  (add-op +put+              #\p  "store stack top in memo; index is string arg")
  (add-op +binput+           #\q  "store stack top in memo; index is 1-byte arg")
  (add-op +long-binput+      #\r  "store stack top in memo; index is 4-byte arg")
  (add-op +setitem+          #\s  "add key+value pair to dict")
  (add-op +tuple+            #\t  "build tuple from topmost stack items")
  (add-op +empty-tuple+      #\)  "push empty tuple")
  (add-op +setitems+         #\u  "modify dict by adding topmost key+value pairs")
  (add-op +binfloat+         #\G  "push float; arg is 8-byte float encoding")
  
  (add-op +ture+             (+ #.(char-code #\I) 0 1 #.(char-code #\newline)) "not an opcode; see INT docs in pickletools.py")
  (add-op +false+            (+ #.(char-code #\I) 0 0 #.(char-code #\newline)) "not an opcode; see INT docs in pickletools.py")

  ;;;;Protocol 2
  (add-op +proto+            #x80 "identify pickle protocol")
  (add-op +newobj+           #x81 "build object by applying cls.__new__ to argtuple")
  (add-op +ext1+             #x82 "push object from extension registry; 1-byte index")
  (add-op +ext2+             #x83 "ditto, but 2-byte index")
  (add-op +ext4+             #x84 "ditto, but 3-byte index")
  (add-op +tuple1+           #x85 "build 1-tuple from stack top")
  (add-op +tuple2+           #x86 "build 2-tuple from two topmost stack items")
  (add-op +tuple3+           #x87 "build 3-tuple from three topmost stack items")
  (add-op +newtrue+          #x88 "push True")
  (add-op +newfalse+         #x89 "push False")
  (add-op +long1+            #x8a "push long from < 256 bytes")
  (add-op +long4+            #x8b "push really big long")

  ;; (add-op +_tuplesize2code+  (vector +empty-tuple+ +tuple1+ +tuple2+ +tuple3+) "tuplesize2code")

  ;;;;Protocol3
  (add-op +binbytes+         #\B "push bytes; counted binary string argument")
  (add-op +short-binbytes+   #\C "push bytes; counted binary string argument < bytes")

  ;;;;Protocol4
  (add-op +short-binunicode+ #x8c "push short string; UTF-8 length < 256 bytes")
  (add-op +binunicode8+      #x8d "push very long string")
  (add-op +binbytes8+        #x8e "push very long bytes string")
  (add-op +empty-set+        #x8f "push empty set on the stack")
  (add-op +additems+         #x90 "modify set by adding topmost stack items")
  (add-op +frozenset+        #x91 "build frozenset from topmost stack items")
  (add-op +newobj-ex+        #x92 "like NEWOBJ but work with keyword only arguments")
  (add-op +stack-global+     #x93 "same as GLOBAL but using names on the stacks")
  (add-op +memoize+          #x94 "store top of the stack in memo")
  (add-op +frame+            #x95 "indicate the beginning of a new frame")

  ;;;;Protocol5
  (add-op +bytearray8+       #x96 "push bytearray")
  (add-op +next-buffer+      #x97 "push next out-of-band buffer")
  (add-op +readonly-buffer+  #x98 "make top of stack readonly")


  ;;;;lisp type 2 python type
  (add-op +lsp-nil+          (type-to-code nil)  "")
  (add-op +lsp-bool+         (type-to-code t)    "")
  (add-op +lsp-int+          (type-to-code 1)    "")
  (add-op +lsp-float+        (type-to-code 1.0)  "")
  (add-op +lsp-str+          (type-to-code "1")  "")
  (add-op +lsp-list+         (type-to-code (list 1))  "")
  (add-op +lsp-array+        (type-to-code (make-array 0)) "")
  (add-op +lsp-hash-table+   (type-to-code (make-hash-table)) "")
  (add-op +lsp-symbol+       (type-to-code #'car) "")
  )

